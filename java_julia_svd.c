/*
  This file contains JNI code that allows Java classes to call 
  C routines that use Julia to SVD results.
 */


#include <jni.h>
#include "svd_fcns.h"
#include "java_julia_svd.h"  // auto-generated by javac or javah



/*
 *  Apply SVD, return only singular values.
 */
JNIEXPORT jdoubleArray JNICALL
Java_java_1julia_1svd_get_1singularvals
(JNIEnv *env, jobject obj, jdoubleArray java_in_matrix, jint nrows, jint ncols)
{
  jsize n_inmatrix = (*env)->GetArrayLength(env, java_in_matrix);
  double *in_matrix = (*env)->GetDoubleArrayElements(env, java_in_matrix, 0);

#ifdef DEBUG
  fprintf(stdout,"In C fcn Java_java_1julia_1svd_get_1singularvals, n_inmatrix=%d\n",n_inmatrix);
  fprintf(stdout,"data:\n");
  for(int i=0;i<n_inmatrix;i++){
    fprintf(stdout,"%f\n",in_matrix[i]);
  }
#endif

  start_julia();

  svd_results mysvd = julia_svd(in_matrix,nrows,ncols);

#ifdef DEBUG
  fprintf(stdout,"singular values in C:\n");
  for(int i=0;i<mysvd.n_singvals;i++)
    {
      fprintf(stdout,"s[%d]=%f\n",i,mysvd.s[i]);
    }
#endif 

  stop_julia();

  (*env)->ReleaseDoubleArrayElements(env, java_in_matrix, in_matrix, 0);


  jdoubleArray result = (*env)->NewDoubleArray(env,mysvd.n_singvals);
  jdouble *result_array = (*env)->GetDoubleArrayElements(env, result, 0);
  for(int i=0;i<mysvd.n_singvals;i++){
    result_array[i] = mysvd.s[i];
  }
  // argument 3 is starting index, argument 4 is number of values to copy
  (*env)->SetDoubleArrayRegion(env, result, 0, mysvd.n_singvals, result_array);

#ifdef DEBUG
    fprintf(stdout,"singular values in C, java array:\n");
    for(int i=0;i<mysvd.n_singvals;i++)
      {
	fprintf(stdout,"s[%d]=%f\n",i,result_array[i]);
      }
#endif


  return(result);
}


/*
 * Apply SVD, then use JNI utilities to create a new Java svd_results 
 * object in to return to the calling Java code.
 *
 */
JNIEXPORT jobject JNICALL
Java_java_1julia_1svd_get_1svd
(JNIEnv *env, jobject obj, jdoubleArray java_in_matrix, jint nrows, jint ncols)
{
  jsize n_input = (*env)->GetArrayLength(env, java_in_matrix);
  double *in_matrix = (*env)->GetDoubleArrayElements(env, java_in_matrix, 0);

  start_julia();

  svd_results mysvd = julia_svd(in_matrix,nrows,ncols);
  (*env)->ReleaseDoubleArrayElements(env, java_in_matrix, in_matrix, 0);

#if DEBUG
  fprintf(stderr,"check svd sizes:\n%d singular values\nU is %d by %d\nVt is %d by %d\n\n",
	  mysvd.n_singvals,mysvd.u_nrows,mysvd.u_ncols,mysvd.vt_nrows,mysvd.vt_ncols);
  
#endif

  stop_julia();

  // set up access to the constructor for results:
  jclass svd_results_class = (*env)->FindClass(env, "svd_results");
  jmethodID svd_results_constructor = (*env)->GetMethodID(env, svd_results_class,
							  "<init>","([DII[D[DII)V");
  if (NULL == svd_results_constructor) return NULL;
  
  // now set up the double arrays for u, s, vt:
  jdoubleArray s_array = (*env)->NewDoubleArray(env,mysvd.n_singvals);
  if (NULL == s_array) return NULL;
  // final arg is boolean, "isCopy"
  jdouble *s_arrayptr = (*env)->GetDoubleArrayElements(env, s_array, 0);
  for(int i=0;i<mysvd.n_singvals;i++){
    s_arrayptr[i] = mysvd.s[i];
  }
  // argument 3 is starting index, argument 4 is number of values to copy
  (*env)->SetDoubleArrayRegion(env, s_array, 0, mysvd.n_singvals, s_arrayptr);
  
  jdoubleArray u_array = (*env)->NewDoubleArray(env,mysvd.u_ncols*mysvd.u_nrows);
  if (NULL == u_array) return NULL;
  jdouble *u_arrayptr = (*env)->GetDoubleArrayElements(env, u_array, 0);
  for(int i=0;i<mysvd.u_nrows*mysvd.u_ncols;i++){
    u_arrayptr[i] = mysvd.u[i];
  }
  (*env)->SetDoubleArrayRegion(env, u_array, 0, mysvd.u_ncols*mysvd.u_nrows, u_arrayptr);
  
  jdoubleArray vt_array = (*env)->NewDoubleArray(env,mysvd.vt_ncols*mysvd.vt_nrows);
  if (NULL == vt_array) return NULL;
  jdouble *vt_arrayptr = (*env)->GetDoubleArrayElements(env, vt_array, 0);
  for(int i=0;i<mysvd.vt_nrows*mysvd.vt_ncols;i++){
    vt_arrayptr[i] = mysvd.vt[i];
  }
  (*env)->SetDoubleArrayRegion(env, vt_array, 0, mysvd.vt_ncols*mysvd.vt_nrows, vt_arrayptr);
  
  // now call constructor with these three arrays:
  jobject the_svd_results = (*env)->NewObject(env, svd_results_class,
  					      svd_results_constructor,
  					      u_array,mysvd.u_nrows,mysvd.u_ncols,
					      s_array,
					      vt_array,mysvd.vt_nrows,mysvd.vt_ncols);

  return(the_svd_results);
}

